#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""AggregateReportsBySection.py

Takes the output generated by JsonBasedReader and converts it into a feature matrix csv.  Also option for loading
ontology data as features that can be generated by SnomedOntologyLookup and RxOntologyLookup.
"""



import os
import re
import sys
from collections import defaultdict
from pathlib import Path

import pandas as pd

from MLDataProcessing import load_dict_json

# disregard_negation_when_adding_original_codes is used to add original codes if negation detection is inconsistent or detrimental
def main(work_dir = None, add_rxnorm_ATC = True, convert_rxcui_to_ingred = True, add_snomed_ontology = True,
         keep_rxnorm_after_conversion = True, disregard_negation_when_adding_original_codes = True):
    while work_dir is None or Path(work_dir).exists() is False:
        work_dir = input("Please enter working directory: ")

    work_dir = Path(work_dir)
    reports_dir = work_dir / "output"

    rxcodes_as_a_fraction_of_all = False
    combine_all_sections = True

    # if disregard_negation_when_adding_original_codes is False
    # only the negation will be added if negation_count/count >= negation_ratio_req
    # and the original code will not be used
    negation_ratio_req = 0.8



    pathlist = Path(reports_dir).glob('*.txt')

    # include missing entries in DF
    NUM_REPORTS = find_max_report_id(reports_dir)
    df_sections = {}

    # load json data for snomed/rxnorm ontologies
    cui_to_ingredients = load_dict_json(work_dir / 'data' / 'rxcui_ingredient.json', create_local_if_not_found=True)
    rxcui_to_atc = load_dict_json(work_dir / 'data' / 'rxcui_atc.json', create_local_if_not_found=True)
    snomed_to_ancestors = load_dict_json(work_dir / 'data' / 'snomed_ancestor_inferred.json', create_local_if_not_found=True)
    valid_rxnorm_codes = load_dict_json('rxcui_found.json', create_local_if_not_found=True)
    valid_snomed_codes = load_dict_json('snomed_found.json', create_local_if_not_found=True)

    print("Loading data from: " + str(reports_dir))

    for id in range(1, NUM_REPORTS+1):
        saved_rx_codes = defaultdict(lambda: defaultdict(int))
        saved_sn_codes = defaultdict(lambda: defaultdict(int))
        rx_count = 0
        try:
            curr = pd.read_csv(str(reports_dir) + "\\REPORT" + str(id) + ".txt")
            if (id % 100 == 0):
                print("Working on File: " + str(id))

            for i in range(len(curr)):
                # print(i, curr.ix[i]['code'], curr.ix[i]['count'], curr.ix[i]['negation'])

                full_code = str(curr.ix[i]['code'])  # use String format after added Family tag to codes
                if len(full_code) > 7 and full_code[7] == '_':
                    section = full_code[0:7]
                    code = full_code[8:]
                else:
                    section = "00000-0"
                    code = full_code


                count = curr.ix[i]['count']
                neg_count = curr.ix[i]['negation']  #old method


                if code[:2] == 'F-':
                    code = code[2:]
                    family_history = True
                else:
                    family_history = False

                neg_status = False
                if disregard_negation_when_adding_original_codes is False:
                    if count > 0 and neg_count/count >= negation_ratio_req:
                        neg_status = True

                # if code[-1] == 'n':
                #     code = code[:-1]
                #     neg_status = True


                if code in valid_rxnorm_codes:
                    if convert_rxcui_to_ingred:
                        convert_success = False
                        if code in cui_to_ingredients and cui_to_ingredients[code]:
                            convert_success = True
                            ingredient_codes = cui_to_ingredients[code]
                            for ingredient in ingredient_codes:
                                temp_code = 'F-' * family_history + ingredient
                                save_code_based_on_negation_settings(saved_rx_codes, section, temp_code, neg_status,
                                                                     neg_count, count,
                                                                     disregard_negation_when_adding_original_codes)

                    # check to see if we should add original code
                    if convert_rxcui_to_ingred == False or (convert_success == False or keep_rxnorm_after_conversion):
                        temp_code = 'F-' * family_history + code
                        save_code_based_on_negation_settings(saved_rx_codes, section, temp_code, neg_status,
                                                             neg_count, count,
                                                             disregard_negation_when_adding_original_codes)
                    if add_rxnorm_ATC:
                        if code in rxcui_to_atc and not neg_status:
                            ATC_list = rxcui_to_atc[code]
                            add_ATC_list(saved_rx_codes, section, ATC_list, 1)
                    if code in rxcui_to_atc or code in cui_to_ingredients:
                        rx_count += 1
                # snomed check for ontology
                elif code in valid_snomed_codes:
                    # add the base code

                    temp_code = 'F-' * family_history + code
                    save_code_based_on_negation_settings(saved_sn_codes, section, temp_code, neg_status,
                                                         neg_count, count,
                                                         disregard_negation_when_adding_original_codes)
                    # look to see if ontology exists and should be added
                    if add_snomed_ontology and code in snomed_to_ancestors and snomed_to_ancestors[code]:
                        ancestors = snomed_to_ancestors[code]
                        for ancestor in ancestors:
                            temp_code = 'F-' * family_history + str(ancestor)
                            save_code_based_on_negation_settings(saved_sn_codes, section, temp_code, neg_status,
                                                                 neg_count, count,
                                                                 disregard_negation_when_adding_original_codes)

                else: #other code:  - will save in snomed section
                    temp_code = 'F-' * family_history + code
                    save_code_based_on_negation_settings(saved_sn_codes, section, temp_code, neg_status,
                                                         neg_count, count,
                                                         disregard_negation_when_adding_original_codes)
            if rxcodes_as_a_fraction_of_all:
                add_saved_codes(saved_rx_codes, id, df_sections, NUM_REPORTS, rx_count)
            else:
                add_saved_codes(saved_rx_codes, id, df_sections, NUM_REPORTS)
            add_saved_codes(saved_sn_codes, id, df_sections, NUM_REPORTS)

        except IOError:
            print("-error with file: " + str(id))
            print(str(sys.exc_info()))



    os.makedirs(work_dir / "section_fm", exist_ok=True)

    for key in df_sections.keys():
        filename = work_dir / "section_fm" / (str(key) + ".csv")
        df_sections[key].to_csv(filename)
        print("File saved: " + str(filename))
        if combine_all_sections:
            df_sections[key].fillna(0,inplace=True)

    if combine_all_sections:
        from MLDataProcessing import combine_list_dfs

        list_of_df = [v for _, v in df_sections.items()]
        full_fm  = combine_list_dfs(list_of_df)

        # chose not to preprocess data at this point so that it can be done later with various methods
        # transformation = (lambda x: x**(1/3))   # take values to third power to keep higher values closer in scale to lower values
        # normalize_df_columns(full_fm, tf=transformation)

        file_location = work_dir / '_feature_matrix_all_sections_.csv'
        full_fm.mask(full_fm.eq(0)).to_csv(file_location)   # do not save 0's to save file space


        print("File saved: " + str(file_location))



def save_code_based_on_negation_settings(saved_codes, section, code, neg_status, neg_count, count, disregard_negation_when_adding_original_codes):
    if disregard_negation_when_adding_original_codes is False:
        save_code(saved_codes, section, code + 'n' * neg_status, count)
    else:
        save_code(saved_codes, section, code + 'n', neg_count)
        new_count = max(0,count - neg_count)
        save_code(saved_codes, section, code, new_count)

def save_code(saved_codes, section, code, count=1):
    if count == 0:
        return
    else:
        saved_codes[section][code] += count


def add_saved_codes(saved_codes,id, df_sections, last_id, reduction_factor = 1):
    if reduction_factor <= 0:
        reduction_factor = 1
    for section, new_dict in saved_codes.items():
        for code in new_dict.keys():
            value = saved_codes[section][code]
            if reduction_factor != 1:
                value /= reduction_factor
            add_code(section, id, code, df_sections, last_id, value)


def add_code(section, id, code, df_sections, last_id, count=1):
    if section not in df_sections.keys():
        # create new dataframe if necessary
        df_sections[section] = pd.DataFrame("",columns=[],index=range(1, last_id+1))
    df_sections[section].loc[id,code] = count


def add_ATC_list(saved_codes, section,ATC_list,count):
    if not ATC_list:
        return
    for ATC in ATC_list:
        for subcode in [ATC[0:1], ATC[0:3], ATC[0:4], ATC[0:5]]:
            saved_codes[section][subcode] += count


def find_max_report_id(path):
    pathlist = Path(path).glob('*.txt')
    max_id = int(-1)
    for path in pathlist:
        file_name = path.stem
        try:
            id_ = re.findall("\d+$", file_name)
            id_ = int(id_[0])

            if id_ > max_id:
                max_id = id_
        except Exception:
            pass
    print("Final Report # found: ", str(max_id))
    return max_id


if __name__ == '__main__':
    main()